###  V8引擎垃圾回收机制

##### 参考https://v8.dev/blog/concurrent-marking

##### 垃圾回收器
- 依据：代际假说
  - 大部分对象在内存中存在的时间很短
  - 不死的对象，会活得更久
- 基于假说，V8把堆分成新生代和老生代两个区域
  - 新生代 - 空间不大，执行频繁，副垃圾回收器
  - 老生代 - 空间大，主垃圾回收器
##### 副垃圾回收器
- 新生代内存区分为两个区域，本质上相同，都拥有工作状态和空闲状态
  - from space
  - to space
- 大致流程
  - 创建一个对象，假设当前from space处于工作状态，则分配到from space
  - 一段时间后，from space的内存占用达上限
  - 此时V8会对from space做一次垃圾清理标记，将不再使用的对象（从根结点不可达）进行标记
  - 复制未标记的对象，复制到to space中并有序重排，再将from space清空
  - 将from space改为空闲状态，to space改为工作状态
- 问题
  - 随着程序的运行，会有部分对象长期积压，占用新生代区域的空间
  - V8采用晋升机制解决这个问题，晋升的对象将分配到老生代区域进行管理
    - 经历过一次Scavenging算法，且并未被标记清除的，也就是过一次翻转置换操作的对象
    - 在进行翻转置换时，被复制的对象大于space空间的25%
##### 主垃圾回收器
- 老生代区域通常会有新生代晋升的对象以及初始占用空间很大的对象
- 采用的垃圾回收算法（二者结合）
  - 标记-清除（Mark-Sweep），标记不再使用的对象，并清除
    - 会产生大量内存碎片，导致没有空间存储大对象
  - 标记-整理（Mark-Compact），标记不再使用的对象，将未标记的对象左移，而后清理边界外的内存
##### 垃圾回收优化策略
- 并行垃圾回收
  - 开启辅助进程协助完成垃圾清理
- 增量垃圾回收
  - 维护标记位和标记工作表（队列）实现标记
  - 标记位：黑 灰 白
- 并发垃圾回收