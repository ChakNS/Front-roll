### This

- 绝大多数情况下，函数的调用方式决定了`this`的指向，即运行时绑定，且过程中不允许被赋值
- 非严格模式下，总是指向一个对象，严格模式下可以是任意值，可能为`undefined`，如在类中
- `bind`可以永久设置`this`指向
#### 类中的`this`
- 类中的方法，若进入执行环境时没有设置`this`的值，this将保持`undefined`
- 类中的方法，`this`指向取决于调用方式，一般通过`bind`统一指向实例，防止混乱
- 类中`this`是一个常规对象，类中所有非静态方法都会被添加到`this`的原型中
- 派生类（子类）不具备初始的`this`绑定，通过在构造函数中调用`super()`可以生成`this`绑定，相当于`this = new Base()`
  - 在调用`super`之前禁止使用`this`
  - 派生类的构造函数禁止在`super`调用之前返回，除非返回的是一个对象，或者不具备构造函数

#### 构造函数中的`this`
- 始终保持为通过`new`关键字创建的实例对象
- 如果构造函数手动返回其他的对象，与`this`绑定的默认对象将被丢弃

#### 箭头函数的`this`
- 箭头函数不提供自身的`this`，始终为父级作用域（封闭词法环境）的值
- 换句话说，箭头函数在什么执行环境下被创建，`this`就保持为该执行环境的值

#### `getter`、`setter`中的`this`
- 函数在`getter`、`setter`中被调用，`this`绑定到设置或获取属性的对象

#### `DOM`事件处理函数中的`this`
- 大多数情况下，指向触发事件的元素（一些浏览器在非`addEventListener`添加监听函数时不遵守该约定）
- 内联事件的`this`指向监听器所在的`DOM`元素（仅适用于外层函数，内层函数如果不指定，将指向`window`，如`alert`中嵌套匿名函数）

