### 变量提升

- 准确的解释：生成执行环境时，会有两个阶段。第一个阶段是创建阶段，JS解释器会找出需要提升的变量和函数，并提前开辟内存空间，函数则直接存入内存，变量只声明并赋值为undefined。
- 后声明的函数会覆盖前一个函数，同名变量和函数，函数优先。
- `let/const`并非不提升，而是本身的特性导致不能在声明前使用。
### 暂时性死区
- 特定作用域中（模块、函数、块级作用域），在`let/const`未被显式赋值之前，即为暂时性死区，禁止对变量进行读写。
- 实际上就是变量提升的体现，`let/const`声明的变量在提升时，不做隐式赋值，如果离开暂时性死区，变量未变显式赋值，才会被赋值为`undefined`。
- 下面例子，如果函数中没有声明`x`，函数作用域链会找到外层关于`x`的定义，如果在函数中声明`x`，则会报禁止读取的错误，而不是`x not defined`，正是变量提升，阻断了函数作用域链。
```js
let x = 'outside'

const a = function () {
	// let x
	
	// ----死区----
  console.log(x)
  // ----死区----
  let x = 'inside' // 如果注释这一段，会打印outside
}

a()

// ReferenceError
```
- 由于JS解释器的规则，死区还体现在表达式、函数默认参数中
```js
let a = a + 1 // 先运行等式右边，此时为暂时性死区

// ReferenceError
```

```js
function fn (a = b, b) { // 参数从左向右解析，此时为b的暂时性死区

}

fn()
// ReferenceError
```