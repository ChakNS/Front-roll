# 缓存

## 分类

前端缓存分为强缓存和协商缓存两种

### 强缓存

强缓存主要使用Expires、Cache-Control两个头字段

Cache-Control优先级更高

命中强缓存时，不会请求服务器，直接从缓存中读取内容，并返回HTTP状态码200

- Expires
  
    > 响应头，服务端返回，代表该资源的过期时间。是一个GMT 格式的标准时间。
    > 
    
    优点
    
    - 在过期时间以内，为用户省了很多流量
    - 减少了服务器重复读取磁盘文件的压力
    
    缺点
    
    - 缓存过期以后，服务器不管文件有没有变化会再次请求服务器
    - 缓存过期时间是一个具体的时间，并且依赖于客户端的时间，如果时间不准确或者被改动缓存也会随之受到影响
- Cache-Control
  
    > HTTP1.1新增，请求/响应头，缓存控制字段，精确控制缓存策略。
    > 
    
    **Cache-Control 服务端参数**
    
    - max-age: 有效相对时间，单位为秒
    - s-maxage: 用于表示 cache 服务器上（比如 cache CDN，缓存代理服务器）的缓存的有效时间，只对 public 缓存有效
    - no-cache: 不使用本地强缓存，使用协商缓存
    - no-store: 禁止浏览器缓存数据，每次都向服务器请求完整资源
    - public: 可以被所有用户缓存，包括终端用户和代理服务器
    - private: 只能被终端用户的浏览器缓存，默认
    
    **Cache-Control 客户端参数**
    
    - max-stale: 客户端向代理服务器拿缓存时，只要代理缓存过期时间在x秒内，仍可以从代理获取
    - min-fresh: 表示代理缓存需要保持一定的新鲜度，在过期前x秒之前刷新缓存
    - only-if-cached: 客户端只接收缓存，不接受源服务器的响应，如果缓存失效，直接返回504
- pragma
  
    > 已逐渐抛弃，优先级是 pragma > cache-control > expires
    > 

### 协商缓存

If-Modified-Since / Last-Modified

Etag / If-None-Match

命中协商缓存时，服务器返回HTTP状态码304，让客户端从本地缓存读取

- If-Modified-Since

> 请求头，资源最近修改时间，由浏览器告诉服务器。其实就是第一次访问服务端返回的Last-Modified的值。
> 
- Last-Modified

> 响应头，资源最近修改时间，由服务器告诉浏览器。只精确到秒，所以存在同一秒即修改文件又获取文件，导致资源不更新的问题。
> 
- Etag

> 响应头，资源标识，由服务器告诉浏览器。由文件修改时间和文件大小计算生成，解决同一秒内即修改又获取的问题。
> 
- If-None-Match

> 请求头，缓存资源标识，由浏览器告诉服务器。其实就是第一次访问服务端返回的Etag的值。
> 

## 缓存失效

资源更新，但仍读取缓存的解决方案

- 老方案
  
    > 通过人工修改文件名或在文件名后加上版本号、时间戳，强制缓存失效
    > 
- 新方案
  
    > 使用构建工具比如Wbpack、Gulp、Grunt等构建工具自动构建，根据文件名或文件内容自动计算hash值来给文件命名
    > 

## 缓存到底存在哪

按缓存位置分类可以分为memory cache、disk cache、Service Worker

- memory cache

> 非持久化存储，浏览器行为，无法操作
> 
- disk cache

> 也叫HTTP cache，持久化存储，允许相同的资源在跨会话，甚至跨站点的情况下使用，浏览器行为，无法操作
> 
- service work

> 持久化存储，有两种情况会导致这个缓存中的资源被清除：调用cache.delete(resource)
或者容量超过限制，被浏览器全部清空。
>